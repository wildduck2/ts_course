# Chapter 12: TypeScript Modules

In this chapter, we’ll learn about **modules** in TypeScript, which allow us to organize code into smaller, reusable, and maintainable pieces.

Modules help avoid naming collisions, improve readability, and make it easier to share code across projects.

---

## 1. What is a Module?

A **module** in TypeScript is any file that contains an `import` or `export` statement.
Each module has its own **scope**. Variables, classes, or functions defined in one module are not visible in others unless explicitly exported.

---

## 2. Exporting from a Module

There are two main ways to export:

### Named Exports

You can export multiple things from a file.

```ts
// math.ts
export const PI = 3.14159;

export function add(a: number, b: number): number {
  return a + b;
}

export class Calculator {}
```

```ts
// app.ts
import { PI, add, Calculator } from "./math";

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5
```

---

### Default Exports

Each module can have **one default export**.

```ts
// logger.ts
export default function log(message: string) {
  console.log(`Log: ${message}`);
}
```

```ts
// app.ts
import log from "./logger";

log("Hello World"); // Log: Hello World
```

---

## 3. Import Syntax Variations

You can rename imports and use `*` to import everything.

```ts
import { add as sum } from "./math";
console.log(sum(2, 3)); // 5

import * as MathUtils from "./math";
console.log(MathUtils.PI); // 3.14159
```

---

## 4. Re-exports

You can **re-export** from other modules, useful for building libraries.

```ts
// shapes.ts
export interface Shape {
  getArea(): number;
}

// index.ts
export * from "./math";
export * from "./shapes";
```

```ts
// app.ts
import { PI, Shape } from "./index";
```

---

## 5. Module Resolution

TypeScript uses **module resolution strategies** to figure out where an import comes from:

* **Node.js style** (default) → looks for `node_modules` and relative paths.
* **Classic style** → older TypeScript resolution (rarely used).

Configuration is controlled in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "moduleResolution": "node",
    "baseUrl": "./src",
    "paths": {
      "@utils/*": ["utilities/*"]
    }
  }
}
```

---

## 6. ES Modules vs CommonJS

TypeScript supports both **ES Modules (ESM)** and **CommonJS (CJS)**.

* **ES Modules** → `import/export` (modern standard).
* **CommonJS** → `require/module.exports` (Node.js legacy).

```ts
// CommonJS example
const fs = require("fs");

// ES Module example
import * as fs from "fs";
```

You can set this in `tsconfig.json`:

```json
{
  "compilerOptions": {
    "module": "ESNext"   // or "CommonJS"
  }
}
```

---

## 7. Ambient Modules

Sometimes, you need to describe modules that don’t have TypeScript typings.
This is done with `declare module`.

```ts
declare module "external-lib" {
  export function coolFeature(): void;
}
```

---

## 8. Summary

* A **module** is any file with `import` or `export`.
* You can use **named exports** or a single **default export**.
* Imports can be renamed or grouped with `*`.
* **Re-exports** help build modular libraries.
* Module resolution determines how imports are found.
* TypeScript supports both **ES Modules** and **CommonJS**.
* **Ambient modules** allow you to type external code.
