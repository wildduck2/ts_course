# Chapter 10: TypeScript Interfaces

In this chapter, we’ll learn about **interfaces in TypeScript**, one of the most powerful features for defining the shape of objects and ensuring type safety.

Interfaces act like **contracts**: they describe what an object should look like, without specifying how it works.

---

## 1. What is an Interface?

An **interface** defines the structure of an object. It describes the **properties** and **methods** that must exist, but not their implementation.

```ts
interface Person {
  name: string;
  age: number;
}

const user: Person = {
  name: "Ahmed",
  age: 25,
};
```

If you forget a property or add an extra one, TypeScript will throw an error.

---

## 2. Optional and Readonly Properties

* **Optional properties (`?`)** → not required.
* **Readonly properties (`readonly`)** → cannot be changed once set.

```ts
interface User {
  readonly id: number;
  username: string;
  email?: string; // optional
}

const u: User = { id: 1, username: "ahmed" };

console.log(u.id); // 1
// u.id = 2 ❌ Error: cannot assign to readonly property
```

---

## 3. Function Types in Interfaces

Interfaces can describe **functions** as well as objects.

```ts
interface Greeter {
  (name: string): string;
}

const greet: Greeter = (name) => {
  return `Hello, ${name}`;
};

console.log(greet("Sara")); // Hello, Sara
```

---

## 4. Extending Interfaces

Interfaces can **extend** other interfaces, allowing for reuse and composition.

```ts
interface Animal {
  name: string;
}

interface Dog extends Animal {
  breed: string;
}

const myDog: Dog = {
  name: "Buddy",
  breed: "Golden Retriever",
};
```

---

## 5. Implementing Interfaces in Classes

Classes can **implement** interfaces to guarantee they follow a specific structure.

```ts
interface Flyable {
  fly(): void;
}

class Bird implements Flyable {
  fly(): void {
    console.log("Flying...");
  }
}

const sparrow = new Bird();
sparrow.fly(); // Flying...
```

---

## 6. Index Signatures

Interfaces can represent objects with **dynamic keys** using index signatures.

```ts
interface StringDictionary {
  [key: string]: string;
}

const colors: StringDictionary = {
  red: "#ff0000",
  green: "#00ff00",
  blue: "#0000ff",
};
```

---

## 7. Interfaces vs. Types

Both **interfaces** and **type aliases** can define object shapes, but they differ slightly:

* `interface` → extendable (can be merged and extended).
* `type` → more flexible (can represent unions, primitives, etc.).

```ts
// Interface
interface Point {
  x: number;
  y: number;
}

// Type alias
type Coordinate = {
  x: number;
  y: number;
};
```

> ✅ Best practice: Use `interface` for object contracts, and `type` for unions or advanced compositions.

---

## 8. Intersection Types with Interfaces

Interfaces can be combined with `&` to form **intersection types**.

```ts
interface A {
  a: string;
}

interface B {
  b: number;
}

type AB = A & B;

const obj: AB = {
  a: "hello",
  b: 42,
};
```

---

## 9. Summary

* Interfaces define **contracts** for objects, functions, and classes.
* Use `?` for optional properties and `readonly` for immutable properties.
* Interfaces can **extend each other** and can be **implemented by classes**.
* Index signatures allow describing dynamic objects.
* Interfaces and type aliases are similar, but each has its strengths.
