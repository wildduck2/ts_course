# Chapter 11: TypeScript Decorators

In this chapter, we’ll learn about **decorators** in TypeScript — a special feature that allows us to attach **metadata** or **behavior** to classes, methods, properties, or parameters.

Decorators are widely used in frameworks like **Angular** and **NestJS** to make code more declarative and expressive.

---

## 1. What is a Decorator?

A **decorator** is a function that can be applied to:

* **Classes**
* **Methods**
* **Properties**
* **Accessors (getters/setters)**
* **Method parameters**

They are written with the `@` symbol before the target.

⚠️ **Note:** To use decorators, you must enable them in `tsconfig.json`:

```json
{
  "experimentalDecorators": true,
  "emitDecoratorMetadata": true
}
```

---

## 2. Class Decorators

A **class decorator** is applied to a class declaration. It can modify or replace the class.

```ts
function Logger(constructor: Function) {
  console.log(`Class created: ${constructor.name}`);
}

@Logger
class Person {
  constructor(public name: string) {}
}

// Output: Class created: Person
```

---

## 3. Method Decorators

A **method decorator** is applied to a method, often used for logging, validation, or security checks.

It receives:

* `target` → the prototype of the class
* `propertyKey` → the method name
* `descriptor` → the method’s property descriptor

```ts
function LogMethod(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const original = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with`, args);
    return original.apply(this, args);
  };
}

class Calculator {
  @LogMethod
  add(a: number, b: number) {
    return a + b;
  }
}

const calc = new Calculator();
console.log(calc.add(2, 3));
// Output: Calling add with [2, 3]
```

---

## 4. Property Decorators

A **property decorator** can add metadata or logic to a property.

```ts
function ReadOnly(target: any, propertyKey: string) {
  Object.defineProperty(target, propertyKey, {
    writable: false,
  });
}

class User {
  @ReadOnly
  role = "admin";
}

const user = new User();
user.role = "guest"; // ❌ Error in strict mode
```

---

## 5. Accessor Decorators

Decorators can also be applied to **getters** and **setters**.

```ts
function Configurable(value: boolean) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    descriptor.configurable = value;
  };
}

class Product {
  private _price: number = 0;

  @Configurable(false)
  get price() {
    return this._price;
  }
}
```

---

## 6. Parameter Decorators

A **parameter decorator** is applied to function parameters.
It receives:

* `target` → the class
* `propertyKey` → method name
* `parameterIndex` → the position of the parameter

```ts
function LogParam(target: any, propertyKey: string, parameterIndex: number) {
  console.log(`Parameter at index ${parameterIndex} in method ${propertyKey}`);
}

class Service {
  greet(@LogParam message: string) {
    console.log(message);
  }
}

new Service().greet("Hello!");
```

---

## 7. Decorator Factories

You can create **decorator factories** (functions that return decorators) to customize behavior.

```ts
function Prefix(prefix: string) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const original = descriptor.value;
    descriptor.value = function (...args: any[]) {
      return prefix + original.apply(this, args);
    };
  };
}

class Greeter {
  @Prefix(">> ")
  say(message: string) {
    return message;
  }
}

const g = new Greeter();
console.log(g.say("Hello")); // >> Hello
```

---

## 8. Practical Use Cases

* **Logging & Debugging** → method call tracing.
* **Validation** → enforce constraints on inputs.
* **Metadata** → used by frameworks (NestJS, Angular).
* **Access Control** → check permissions before running a method.
* **Dependency Injection** → register classes with a container.

Example (NestJS-like style):

```ts
function Injectable(constructor: Function) {
  console.log(`${constructor.name} is now injectable`);
}

@Injectable
class AuthService {}
```

---

## 9. Summary

* Decorators are functions applied with `@` to classes, methods, properties, or parameters.
* They allow **metadata, transformation, and behavior injection**.
* Common decorator types:

  * Class decorators
  * Method decorators
  * Property decorators
  * Accessor decorators
  * Parameter decorators
* Widely used in frameworks for **dependency injection, logging, validation, and configuration**.
