# Chapter 13: TypeScript Utility Types

In this chapter, we’ll explore **TypeScript Utility Types** — built-in helpers that let you create new types from existing ones. They save time, reduce duplication, and make code more type-safe.

---

## 1. What Are Utility Types?

Utility types are **generic type helpers** provided by TypeScript. They work by taking an existing type and applying transformations, such as making properties optional, required, or read-only.

They’re especially useful when working with large object types, APIs, or domain models.

---

## 2. Common Utility Types

### `Partial<T>`

Makes all properties in `T` **optional**.

```ts
interface User {
  id: number;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;

const u: PartialUser = { name: "Ahmed" }; // ✅ only `name` provided
```

---

### `Required<T>`

Makes all properties in `T` **required**.

```ts
interface Profile {
  username?: string;
  bio?: string;
}

type CompleteProfile = Required<Profile>;

const p: CompleteProfile = {
  username: "Sara",
  bio: "Developer",
}; // ✅ both fields required
```

---

### `Readonly<T>`

Makes all properties in `T` **immutable**.

```ts
interface Settings {
  theme: string;
  language: string;
}

const s: Readonly<Settings> = {
  theme: "dark",
  language: "en",
};

// s.theme = "light"; ❌ Error
```

---

### `Pick<T, K>`

Creates a type by selecting a subset of properties from `T`.

```ts
interface Product {
  id: number;
  name: string;
  price: number;
}

type ProductPreview = Pick<Product, "id" | "name">;

const item: ProductPreview = { id: 1, name: "Phone" };
```

---

### `Omit<T, K>`

Creates a type by removing properties from `T`.

```ts
type ProductDetails = Omit<Product, "id">;

const details: ProductDetails = { name: "Laptop", price: 1000 };
```

---

### `Record<K, T>`

Creates a type with keys `K` and values of type `T`.

```ts
type Roles = "admin" | "editor" | "viewer";

const permissions: Record<Roles, boolean> = {
  admin: true,
  editor: true,
  viewer: false,
};
```

---

### `Exclude<T, U>`

Removes types from `T` that are assignable to `U`.

```ts
type Roles = "admin" | "editor" | "viewer";
type WithoutEditor = Exclude<Roles, "editor">;

// type WithoutEditor = "admin" | "viewer"
```

---

### `Extract<T, U>`

Keeps only types from `T` that are assignable to `U`.

```ts
type Events = "click" | "scroll" | "mousemove";
type MouseEvents = Extract<Events, "scroll" | "mousemove">;

// type MouseEvents = "scroll" | "mousemove"
```

---

### `NonNullable<T>`

Removes `null` and `undefined` from `T`.

```ts
type Value = string | null | undefined;
type StrictValue = NonNullable<Value>;

// type StrictValue = string
```

---

### `ReturnType<T>`

Gets the return type of a function.

```ts
function getUser() {
  return { id: 1, name: "Ahmed" };
}

type UserReturn = ReturnType<typeof getUser>;
// { id: number; name: string }
```

---

### `Parameters<T>`

Gets the types of parameters of a function as a tuple.

```ts
function login(username: string, password: string) {
  return true;
}

type LoginParams = Parameters<typeof login>;
// [string, string]
```

---

### `ConstructorParameters<T>`

Gets the parameter types of a class constructor.

```ts
class Car {
  constructor(public brand: string, public year: number) {}
}

type CarParams = ConstructorParameters<typeof Car>;
// [string, number]
```

---

### `InstanceType<T>`

Gets the instance type of a class.

```ts
type CarInstance = InstanceType<typeof Car>;
// Car
```

---

## 3. Combining Utility Types

You can combine multiple utility types to build powerful transformations.

```ts
interface Todo {
  id: number;
  title: string;
  completed: boolean;
}

type TodoPreview = Readonly<Pick<Todo, "id" | "title">>;

const todo: TodoPreview = { id: 1, title: "Learn TS" };
// todo.title = "New Title"; ❌ Error (readonly)
```

---

## 4. Summary

* Utility types let you transform existing types instead of rewriting them.
* Most common ones: `Partial`, `Required`, `Readonly`, `Pick`, `Omit`.
* Advanced ones: `Exclude`, `Extract`, `NonNullable`, `ReturnType`, `Parameters`.
* They help create **flexible, DRY, and safe** type definitions.

