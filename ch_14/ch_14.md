# Chapter 14: Advanced TypeScript

This chapter digs into **advanced TypeScript** features and patterns — the parts that let you *shape types like code*, build safer APIs, and push the type system to do heavy lifting for you. Expect conditional types, mapped types, `keyof` tricks, template literal types, recursive types, type inference with `infer`, variance, advanced generics, and practical tips & pitfalls.

---

## 1. Key Concepts Overview

* **Indexed access types** (`T[K]`) — pick a property type by key.
* **`keyof` operator** — get keys of a type as a union.
* **Mapped types** (`{ [K in Keys]: ... }`) — transform property sets.
* **Conditional types** (`T extends U ? X : Y`) — type-level `if`.
* **`infer`** — extract a type inside a conditional type.
* **Distributive conditional types** — conditional types distribute over unions.
* **Template literal types** — build string unions/transformations.
* **Recursive types & tail recursion patterns** — model nested structures.
* **Type guards / user-defined type predicates** — runtime checks that refine types.
* **Variance & assignability** — covariance, contravariance, bivariance pitfalls.
* **`unknown`, `any`, `never`** — the special utility types.
* **Branded/nominal typing** — simulate nominal types with `unique symbol` or branding.

---

## 2. `keyof` and Indexed Access Types

```ts
type Person = { name: string; age: number };
type PersonKeys = keyof Person; // "name" | "age"
type NameType = Person["name"]; // string

function pluck<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}
```

`keyof` + indexed access lets you write safe property utilities.

---

## 3. Mapped Types

Transform all properties of a type:

```ts
type Readonly<T> = { readonly [K in keyof T]: T[K] };
type Partial<T> = { [K in keyof T]?: T[K] };

type User = { id: number; name: string };
type ReadonlyUser = Readonly<User>;
```

You can change modifiers and even remap keys:

```ts
type Nullable<T> = { [K in keyof T]: T[K] | null };

type RenameKeys<T> = {
  [K in keyof T as `_${string & K}`]: T[K]; // remap key names using `as`
};
```

---

## 4. Conditional Types

A compile-time `if`:

```ts
type IsString<T> = T extends string ? true : false;
type A = IsString<"a">; // true
type B = IsString<number>; // false
```

**Distributive behavior**: when `T` is a union, conditional types distribute:

```ts
type Wrapped<T> = T extends any ? { value: T } : never;
type Example = Wrapped<"a" | "b">; // {value: "a"} | {value: "b"}
```

Use wrapping with a tuple to **prevent distribution**: `T extends [infer U] ? ...` or `T extends any[] ? ...`.

---

## 5. `infer` — Extracting Types

`infer` pulls out a part of a type inside a conditional:

```ts
type Return<T> = T extends (...args: any[]) => infer R ? R : never;

type Fn = (x: number) => string;
type R = Return<Fn>; // string
```

You can extract from tuples, promises, etc.:

```ts
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T;
```

---

## 6. Building Utility Types (examples)

Implementing `ReturnType`:

```ts
type MyReturnType<T> = T extends (...args: any[]) => infer R ? R : never;
```

A `DeepPartial` recursive mapped type:

```ts
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};
```

Be careful: `T extends object` treats functions as objects. Use `T extends Record<string, any>` or exclude functions when needed.

---

## 7. Template Literal Types

Create new string unions or transform strings:

```ts
type Direction = "up" | "down";
type EventName = `on${Capitalize<Direction>}`; // "onUp" | "onDown"

type LocalePrefix<L extends string> = `${L}/api`;
type API = LocalePrefix<"en" | "ar">; // "en/api" | "ar/api"
```

You can use built-in string transforms: `Uppercase`, `Lowercase`, `Capitalize`, `Uncapitalize`.

---

## 8. Recursive Types & Tail Recursion

Recursive types can model trees or nested structures:

```ts
type JSONValue = 
  | string
  | number
  | boolean
  | null
  | { [k: string]: JSONValue }
  | JSONValue[];
```

Be mindful of TypeScript’s recursion depth limits (very deep recursion may fail to compile). Try to flatten or limit recursion where possible.

---

## 9. Type Guards & Type Predicates

Refine types at runtime so TypeScript narrows the type:

```ts
function isString(x: unknown): x is string {
  return typeof x === "string";
}

function example(v: unknown) {
  if (isString(v)) {
    // v: string here
    console.log(v.toUpperCase());
  }
}
```

Use `x is T` predicates to teach the compiler.

---

## 10. `unknown`, `any`, `never`

* `any` — opt-out of checking (unsafe).
* `unknown` — safe top-type: you must narrow it before using.
* `never` — indicates impossibility (e.g., function that always throws).

Prefer `unknown` over `any` when handling external inputs.

---

## 11. Variance (Covariance / Contravariance) — Practical View

* **Covariant** = you can assign `Derived` to `Base` (typical for readonly positions).
* **Contravariant** = function parameter positions (TypeScript is bivariant for historical reasons on parameters in some cases).

Example pitfalls (function assignment):

```ts
type Handler<T> = (value: T) => void;
type H1 = Handler<string>;
type H2 = Handler<string | number>;

// H2 can accept number too, so assigning H1 -> H2 is not safe, but TS may allow under bivariant rules in some contexts.
```

Best practice: avoid unsafe `any`-style casts; prefer clear generics and `readonly` where possible.

---

## 12. Advanced Generics Patterns

**Generic constraints**:

```ts
function pluckStrict<T, K extends keyof T>(obj: T, keys: K[]): T[K][] {
  return keys.map(k => obj[k]);
}
```

**Default type parameters** and **conditional generic behavior**:

```ts
type Result<T, U = T extends any[] ? T[number] : T> = U;
```

**Higher-kinded emulation**: TypeScript doesn’t have native HKTs, but you can approximate patterns (complex — use libraries if needed).

---

## 13. Branded (Nominal) Types

Simulate nominal types to prevent accidental mixing of primitive-based IDs:

```ts
type Brand<K, T> = K & { __brand: T };

type UserId = Brand<number, "User">;
type OrderId = Brand<number, "Order">;

function makeUserId(id: number): UserId {
  return id as UserId;
}

const u = makeUserId(1);
// const mixed: OrderId = u; // Error
```

Alternatively use `unique symbol` with interfaces for stronger guarantees.

---

## 14. Common Pitfalls & Gotchas

* **Excess property checks** apply only on object literals.
* **Recursive mapped types** may hit compiler recursion limits.
* **Conditional distributivity** can be surprising — wrap unions in tuples to avoid it when needed.
* **`object` vs `Record<string, any>`** — `object` matches functions too; if you want plain objects use `Record` or `{} & {}` carefully.
* **Bivariance of function parameters** in older TS versions leads to unsafe assignments — be explicit with `strictFunctionTypes: true` (recommended).
* **`any` leaks** cause loss of checking; prefer `unknown` and narrow.

---

## 15. Practical Examples

### Type-safe `get` utility

```ts
function get<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "A", age: 30 };
const name = get(person, "name"); // string
```

### DeepReadonly (exclude functions)

```ts
type DeepReadonly<T> = T extends Function
  ? T
  : T extends Array<infer U>
  ? ReadonlyArray<DeepReadonly<U>>
  : T extends object
  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
  : T;
```

---

## 16. Best Practices

* **Prefer composition of small utility types** over huge single-type monsters.
* **Favor `unknown` over `any`** for external inputs and narrow ASAP.
* **Enable `strict` mode** and `strictFunctionTypes`.
* **Write unit tests for complex type-level logic** (e.g., using `tsd` or `dtslint`).
* **Comment non-obvious type hacks** so future readers understand intent.
* **Use branded types** for safety where different IDs could be mixed.

---

## 17. Summary

Advanced TypeScript lets you program at the type level: transform types, extract pieces, and build safer libraries. The key tools are `keyof`, indexed access, mapped types, conditional types, `infer`, template literal types, and recursive types. Combine them carefully and prefer clarity over cleverness.

---

### Exercises (optional)

1. Implement `DeepRequired<T>` — make nested properties required.
2. Create a `StringifyKeys<T>` mapped type that returns a type where keys are stringified (e.g., `{a: number}` → `{"a": number}`).
3. Build a branded `Email` type and a runtime `isEmail` type guard that narrows `unknown` to `Email`.
